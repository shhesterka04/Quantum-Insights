Algorithm: Pell's Equation
Speedup: Superpolynomial
Description: Given a positive nonsquare integer d, Pell's equation is x2−dy2=1
. For any such d there are infinitely many pairs of integers (x,y) solving this equation. Let (x1,y1)
 be the pair that minimizes x+yd−−√
. If d is an n-bit integer (i.e. 0≤d<2n
 ), (x1,y1)
 may in general require exponentially many bits to write down. Thus it is in general impossible to find (x1,y1)
 in polynomial time. Let R=log(x1+y1d−−√)
. ⌊R⌉
 uniquely identifies (x1,y1)
. As shown by Hallgren [49], given a n-bit number d, a quantum computer can find ⌊R⌉
 in poly(n) time. No polynomial time classical algorithm for this problem is known. Factoring reduces to this problem. This algorithm breaks the Buchman-Williams cryptosystem. See also Abelian hidden subgroup.


Algorithm:Primality Proving
Speedup:Polynomial
Description: Given an n-bit number, return a proof of its primality. The fastest classical algorithms are AKS, the best versions of which [393, 394] have essentially-quartic complexity, and ECPP, where the heuristic complexity of the fastest version [395] is also essentially quartic. The fastest known quantum algorithm for this problem is the method of Donis-Vela and Garcia-Escartin [396], with complexity O(n2(log n)3log log n)
. This improves upon a prior factoring-based quantum algorithm for primality proving [397] that has complexity O(n3log n log log n)
. A recent result of Harvey and Van Der Hoeven [398] can be used to improve the complexity of the factoring-based quantum algorithm for primality proving to O(n3logn)
 and it may be possible to similarly reduce the complexity of the Donis-Vela-Garcia-Escartin algorithm to O(n2(log n)3)
 [399].


Algorithm:Solving Exponential Congruences
Speedup:Polynomial
Description: We are given a,b,c,f,g∈Fq
. We must find integers x,y
 such that afx+bgy=c
. As shown in [111], quantum computers can solve this problem in O˜(q3/8)
 time whereas the best classical algorithm requires O˜(q9/8)
 time. The quantum algorithm of [111] is based on the quantum algorithms for discrete logarithms and searching.


Algorithm: Verifying Matrix Products
Speedup: Polynomial
Description: Given three n×n
 matrices, A,B, and C, the matrix product verification problem is to decide whether AB=C. Classically, the best known algorithm achieves this in time O(n2)
, whereas the best known classical algorithm for matrix multiplication runs in time O(n2.373)
. Ambainis et al. discovered a quantum algorithm for this problem with runtime O(n7/4)
 [6]. Subsequently, Buhrman and Špalek improved upon this, obtaining a quantum algorithm for this problem with runtime O(n5/3)
 [19]. This latter algorithm is based on results regarding quantum walks that were proven in [85].

Algorithm: Ordered Search
Speedup: Constant factor
Description: We are given oracle access to a list of N numbers in order from least to greatest. Given a number x, the task is to find out where in the list it would fit. Classically, the best possible algorithm is binary search which takes log2N
 queries. Farhi et al. showed that a quantum computer can achieve this using 0.53 log2N
 queries [39]. Currently, the best known deterministic quantum algorithm for this problem uses 0.433 log2N
 queries [103]. A lower bound of ln2πlog2N
 quantum queries has been proven for this problem [219, 24]. In [10], a randomized quantum algorithm is given whose expected query complexity is less than 13log2N
.

Algorithm: Matrix Commutativity
Speedup: Polynomial
Description: We are given oracle access to k matrices, each of which are n×n
. Given integers i,j∈{1,2,…,n}
, and x∈{1,2,…,k}
 the oracle returns the ij matrix element of the xth
 matrix. The task is to decide whether all of these k matrices commute. As shown by Itakura [54], this can be achieved on a quantum computer using O(k4/5n9/5)
 queries, whereas classically this requires Ω(kn2)
 queries.


Algorithm: Group Commutativity
Speedup: Polynomial
Description: We are given a list of k generators for a group G and access to a blackbox implementing group multiplication. By querying this blackbox we wish to determine whether the group is commutative. The best known classical algorithm is due to Pak and requires O(k) queries. Magniez and Nayak have shown that the quantum query complexity of this task is Θ˜(k2/3)
 [139].


Algorithm: Group Isomorphism
Speedup: Superpolynomial
Description: Let G be a finite group. To every element of G is assigned an arbitrary label (bit string). Given an ordered pair of labels of group elements, the group oracle returns the label of their product. Given access to the group oracles for two groups G and G', and a list of generators for each group, we must decide whether G and G' are isomorphic. For Abelian groups, we can solve this problem using poly(log |G|, log |G'|) queries to the oracle by applying the quantum algorithm of [127], which decomposes any Abelian group into a canonical direct product of cyclic groups. The quantum algorithm of [128] solves the group isomorphism problem using poly(log |G|, log |G'|) queries for a certain class of non-Abelian groups. Specifically, a group G is in this class if G has a normal Abelian subgroup A and an element y of order coprime to |A| such that G = A, y. Zatloukal has recently given an exponential quantum speedup for some instances of a problem closely related to group isomorphism, namely testing equivalence of group extensions [202].


Algorithm: Statistical Difference
Speedup: Polynomial
Description: Suppose we are given two black boxes A and B whose domain is the integers 1 through T and whose range is the integers 1 through N. By choosing uniformly at random among allowed inputs we obtain a probability distribution over the possible outputs. We wish to approximate to constant precision the L1 distance between the probability distributions determined by A and B. Classically the number of necessary queries scales essentially linearly with N. As shown in [117], a quantum computer can achieve this using O(N−−√)
 queries. Approximate uniformity and orthogonality of probability distributions can also be decided on a quantum computer using O(N1/3)
 queries. The main tool is the quantum counting algorithm of [16]. A further improved quantum algorithm for this task is obtained in [265].


Algorithm: Counterfeit Coins
Speedup: Polynomial
Description: Suppose we are given N coins, k of which are counterfeit. The real coins are all of equal weight, and the counterfeit coins are all of some other equal weight. We have a pan balance and can compare the weight of any pair of subsets of the coins. Classically, we need Ω(klog(N/k))
 weighings to identify all of the counterfeit coins. We can introduce an oracle such that given a pair of subsets of the coins of equal cardinality, it outputs one bit indicating balanced or unbalanced. Building on previous work by Terhal and Smolin [137], Iwama et al. have shown [136] that on a quantum computer, one can identify all of the counterfeit coins using O(k1/4)
 queries. The core techniques behind the quantum speedup are amplitude amplification and the Bernstein-Vazirani algorithm.


